#!/bin/sh

# Personal Certificate Authority
#
# Copyright (c) 2018 Michael Graves <mgraves@brainfat.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

OS="openssl"

function die {
	local _rc=${1:?1}; shift;
	local _out=$*
#XXX clean up any temporary files
	if [ ! -z "$_out" ]; then
		echo "$_out"
	fi
	exit $_rc 
}

function syntax {
	local _rc=${1:?0}
	echo "${0##/} <ca> <command> [options]"
	echo "Commands:"
	echo "  <ca> init"
	echo "  <ca> config list <macros | pol[icy] | ext[ension]>"
	echo "  <ca> config get macro <-key xxx> <-value>"
	echo "  <ca> config set macro <-key xxx> <-value xxx>"
	echo "  <ca> config get pol|ext <-name> <-key xxx> <-value>"
	echo "  <ca> config set pol|ext <-name> <-key xxx> <-value xxx>"
	echo "  <ca> create root [-days #] [-bits #]"
	echo "  <ca> create key <-name name> [-bits #]"
	echo "  <ca> create req[uest] <-name name> <-key file | -newkey> [-sign] [-days #] [-san val ...]"
	echo "  <ca> sign <-name name> [-self] [-days] [-san val ...]"
	echo "  <ca> show root [same options as show cert]"
	echo "  <ca> show req [-name name]"
	echo "  <ca> show cert [-name name] [-serial] [-expire] [-subject] [-subjecthash] [-issuer] [-issuerhash] [-fingerprint]"
	echo ""
	die $_rc
}

function get_root {
	echo ".$1.ca"
}

function check_ca {
	local _ca=$1
	if [ -z $_ca ]; then
		echo "no CA specified"
		return 1
	fi
	if [ ! -d ./.$_ca.ca ]; then
		echo "CA '$_ca' not found. Must first be initialzed"
		return 1
	fi
}

function read_config {
	local _ca=$1
	[ -z "$_ca" ] && return 1
	local _root=`get_root $_ca`
	if [ ! -f $_root/config/macros ]; then
		die 1 "cannot read config"
	fi
	. $_root/config/macros
#	local _ofs=$IFS
#	cat $_root/config.env | grep -v "^#" | while IFS="=" read k v; do
#		_cfg[$k]=$v
##		export $k=$v
#	done
#	IFS=$_ofs
	return 0
}

function prep_serial {
	local _ca=$1; shift;
	[ -z "$_ca" ] && return 1
	$OS rand -hex 8 > $DBDIR/serial.txt
	return 0
}

function init_ca {
	local _ca=$1
	local _root
	if [ -z $_ca ]; then
		echo "no CA specified"
		return 1
	fi
	_root=`get_root $_ca`
	if [ -d $_root ]; then
		echo "CA $_ca already exists"
		return 1
	fi
	mkdir -p $_root
	mkdir $_root/certs
	mkdir $_root/requests
	mkdir $_root/db
	touch $_root/db/serial.txt
	touch $_root/db/index.txt
	touch $_root/db/index.txt.attr
	mkdir $_root/db/library
	mkdir $_root/crl
	mkdir $_root/private
	mkdir $_root/config
	cat <<EOF> $_root/config/macros
# Personal Certificate Authority config
#
HOME=$_root
RANDFILE=/dev/arandom
CERTDIR=$_root/certs
REQDIR=$_root/requests
DBDIR=$_root/db
LIBDIR=$_root/db/library
CRLDIR=$_root/crl
KEYDIR=$_root/private
ROOTCERT=root-$_ca.crt
ROOTKEY=root-$_ca.key
ROOTCRL=$_ca.crl
CRLDAYS=365
CERTDAYS=365
DEFMD=sha256
DEFBITS=2048
PUBLICURL=xxx
ROOTCHAIN=xxx
EOF

	cat <<EOF> $_root/config/prog_ca
dir				= \$ENV::HOME
certs			= \$ENV::CERTDIR
crl_dir			= \$ENV::CRLDIR
new_certs_dir	= \$ENV::LIBDIR
database 		= \$ENV::DBDIR/index.txt
serial			= \$ENV::DBDIR/serial.txt
certificate		= \$ENV::CERTDIR/\$ENV::ROOTCERT
crl				= \$ENV::CRLDIR/\$ENV::ROOTCERT
private_key		= \$ENV::KEYDIR/\$ENV::ROOTCERT
default_md		= \$ENV::DEFMD
default_bits	= \$ENV::DEFBITS
default_crl_days	= \$ENV::CRLDAYS
default_days	= \$ENV::CERTDAYS
string_mask		= utf8only
nsCertType		= client, email, server
EOF

	cat <<EOF> $_root/config/prog_req
default_days	= \$ENV::CERTDAYS
default_bits	= \$ENV::DEFBITS
default_md		= \$ENV::DEFMD
string_mask		= utf8only
nsCertType		= client, email, server
EOF
	cat <<EOF> $_root/config/req_dn
commonName                      = Common Name (eg, fully qualified host name)
commonName_max                  = 64
countryName                     = Country Name (2 letter code)
countryName_default             = XX
countryName_min                 = 2
countryName_max                 = 2
stateOrProvinceName             = State or Province Name (full name)
#stateOrProvinceName_default    = Confusion
localityName                    = Locality Name (eg, city)
0.organizationName              = Organization Name (eg, company)
0.organizationName_default      = None
organizationalUnitName          = Organizational Unit Name (eg, section)
#organizationalUnitName_default =
emailAddress                    = Email Address
emailAddress_max                = 64
EOF
	cat <<EOF> $_root/config/req_attrs
#challengePassword               = A challenge password
#challengePassword_min           = 4
#challengePassword_max           = 20
#unstructuredName                = An optional company name
EOF
	cat <<EOF> $_root/config/policy_match
countryName	= match
stateOrProvinceName	= optional
localityName = optional
organizationName = match
organizationUnitName = optional
commonName = supplied
emailAddress = optional
subjectAltName = optional
EOF
	cat <<EOF> $_root/config/policy_sign
countryName	= optional
stateOrProvinceName	= optional
localityName = optional
organizationName = optional
organizationUnitName = optional
commonName = supplied
emailAddress = optional
subjectAltName = optional
EOF
	cat <<EOF> $_root/config/extension_ca
basicConstraints = critical,CA:TRUE,pathlen:2
keyUsage = critical,keyCertSign,cRLSign
subjectKeyIdentifier = hash
crlDistributionPoints = URI:\$ENV::PUBLICURL/\$ENV::ROOTCRL
EOF

	cat <<EOF> $_root/config/extension_cert
basicConstraints = critical,CA:FALSE
keyUsage = nonRepudiation,digitalSignature,keyEncipherment
extendedKeyUsage = serverAuth,clientAuth,emailProtection
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid
crlDistributionPoints = URI:\$ENV::PUBLICURL/\$ENV::ROOTCRL
EOF

	return 0	
}

function build_config {
	local _ca=$1; shift
	[ -z "$_ca" ] && return 1
	local _prog=$1; shift
	[ -z "$_prog" ] && return 1
	local _policy
	local _exten
	local _dn
	local _attrs
	local _san
	while [ $# -ne 0 ]; do
		case "$1" in
			-p*)
				_policy=$2
				shift; shift;;
			-e*)
				_exten=$2
				shift; shift;;
			-d*)
				_dn=$2
				shift; shift;;
			-a*)
				_attrs=$2
				shift; shift;;
			-s*)
				if [ ! -z "$2" ]; then
					_san="$_san $2"
				fi
				shift; shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	_tf=`mktemp` || die 1 "build_config: mktemp"
	echo # generated config > $_tf
	cat $HOME/config/macros >> $_tf
	if [ -z "$_prog" -o ! -f $HOME/config/prog_$_prog ]; then
		echo "missing program or config not found"
		rm -f $_tf
		return 1
	fi
	echo "" >> $_tf
	echo "[ $_prog ]" >> $_tf
	if [ "$_prog" == "ca" ]; then
		echo "default_ca=this_ca" >> $_tf
		echo "[ this_ca ]" >> $_tf
	fi
	cat $HOME/config/prog_$_prog >> $_tf
	[ ! -z "$_dn" ] && echo "distinguished_name=$_dn" >> $_tf
	[ ! -z "$_attrs" ] && echo "attributes=$_attrs" >> $_tf
	[ ! -z "$_policy" ] && echo "policy=$_policy" >> $_tf
	[ ! -z "$_exten" ] && echo "x509_extensions=$_exten" >> $_tf
	if [ ! -z "$_dn" ]; then
		if [ -f $HOME/config/$_dn ]; then
			echo "[ $_dn ]" >> $_tf
			cat $HOME/config/$_dn >> $_tf
		else
			echo "missing DN config"
			rm -f $_tf
			return 1
		fi
	fi
	echo "" >> $_tf
	if [ ! -z $_attrs ]; then
		if [ -f $HOME/config/$_attrs ]; then
			echo "[ $_attrs ]" >> $_tf
			cat $HOME/config/$_attrs >> $_tf
		else
			echo "missing attrs config"
			rm -f $_tf
			return 1
		fi
	fi
	echo "" >> $_tf
	if [ ! -z $_policy ]; then
		if [ -f $HOME/config/$_policy ]; then
			echo "[ $_policy ]" >> $_tf
			cat $HOME/config/$_policy >> $_tf
		else
			echo "missing policy config"
			rm -f $_tf
			return 1
		fi
	fi
	echo "" >> $_tf
	if [ ! -z $_exten ]; then
		if [ -f $HOME/config/$_exten ]; then
			echo "[ $_exten ]" >> $_tf
			cat $HOME/config/$_exten >> $_tf
			# SAN MUST ALWAY BE DIRECTLY AFTER extensions
			if [ ! -z "$_san" ]; then
				# must always be in teh cert_ext section
				echo "subjectAltName = @altname" >> $_tf
				echo ""
				echo "[ altname ]" >> $_tf
				for i in $_san; do
					echo $i >> $_tf
				done
			fi
		else
			echo "missing exten config"
			rm -f $_tf
			return 1
		fi
	fi
	echo $_tf
	return 0
}

function key_pass {
	local _ca=$1; shift
	[ -z "$_ca" ] && return 1
	local _n=$1; shift
	[ -z "$_n" ] && return 1
	local _tf=`mktemp -p $KEYDIR $_n.XXXXXX` || die 1 "key_pass: mktemp"
	$OS rand -hex 16 > $_tf
	mv -f $_tf $KEYDIR/$_n.pass || return 1
	return 0
}

function create_key {
	local _ca=$1; shift
	local _n
	local _bits
	[ -z "$_ca" ] && return 1
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			-bits)
				_bits=$2
				shift; shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	if [ -z "$_n" ]; then
		echo "-name not set"
		return 1
	fi
	if [ -z "$_bits" ]; then
		_bits=$DEFBITS
	fi
	if [ -f $KEYDIR/$_n.key ]; then
		echo "key already exists.  delete first"
		return 1
	fi
	key_pass $_ca $_n
	if [ $? -ne 0 ]; then
		echo "error generating key pass"
		return 1
	fi
	local _tf=`mktemp -p $KEYDIR $_n.XXXXXX` || die 1 "create_key: mktemp"
	$OS genrsa -out $_tf $_bits
	$OS rsa -aes256 -passout file:$KEYDIR/$_n.pass -in $_tf -out $KEYDIR/$_n.key	
	rm -f $_tf
	chmod 400 $KEYDIR/$_n.key
	echo $KEYDIR/$_n.key
	return 0
}

function create_root {
	local _ca=$1; shift;
	local _n
	local _key
	local _days
	local _tf
	local _bits
	while [ $# -ne 0 ]; do
		case "$1" in
			-days)
				_days=$2
				shift; shift;;
			-bits)
				_bits=$2
				shift; shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	_n=$ROOTCERT
	if [ -z "$_n" ]; then
		echo "no name specified"
		return 1
	fi
	if [ -f $CERTDIR/$ROOTCERT ]; then
		echo "CA root certificate already exists.  aborting"
		return 1
	fi
	if [ -z "$_bits" ]; then
		# if not specified, make root key 2 * DEFBITS
		_bits=$((DEFBITS * 2))
	fi
	if [ ! -f $KEYDIR/$ROOTKEY ]; then
		_key=`create_key $_ca -name ${ROOTKEY%%.key} -bits $_bits`
		if [ $? -ne 0 ]; then
			echo "error creating root key"
			return 1
		fi
	else
		_key=$KEYDIR/$ROOTKEY
	fi
#	if [ $ROOTKEY -ne ${_key##/} ]; then
#	fi
	if [ -z "$_key" ]; then
		echo "no key specified"
		return 1
	fi
	if [ -z "$_days" ]; then
		_days=$CERTDAYS
	fi
	prep_serial $_ca
	_tf=`build_config $_ca "req" -policy policy_match -ext extension_ca -attrs req_attrs -dn req_dn`
	if [ $? -ne 0 ]; then
		# error building config
		return 1
	fi
	out=`$OS req -config $_tf -new -x509 -key $_key -passin file:$KEYDIR/${_n%%.crt}.pass -out $CERTDIR/$_n -days $_days`
	if [ $? -ne 0 ]; then
		cat $_tf >&2
		rm -f $_tf
		echo $out
		return 1
	fi
	echo $REQDIR/$_n
	rm -f $_tf
	return 0
}

function create_csr {
	local _ca=$1; shift;
	local _n
	local _key
	local _days
	local _san
	local _tf
	local _sign=0
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			-key)
				_key=$2
				shift; shift;;
			-newkey)
				if [ -z "$_n" ]; then
					echo "-name must be set first"
					return 1
				fi 
				_key=`create_key $_ca -name $_n`
				if [ $? -ne 0 ]; then
					echo $_key
					return 1
				fi
				shift;;
			-days)
				_days=$2
				shift; shift;;
			-san)
				if [ ! -z "$2" ]; then
					_san="$_san $2"
				fi
				shift; shift;;
			-sign)
				_sign=1
				shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	if [ -z "$_n" ]; then
		echo "no name specified"
		return 1
	fi
	if [ -z "$_key" ]; then
		echo "no key specified"
		return 1
	fi
	if [ ! -f $_key ]; then
		if [ -f $KEYDIR/$_key ]; then
			_key=$KEYDIR/$_key
		else
			echo "cannot find key file"
			return 1
		fi
	fi
	if [ -z "$_days" ]; then
		_days=$CERTDAYS
	fi
	_tf=`build_config $_ca "req" -policy policy_match -ext extension_cert -a req_attrs -dn req_dn -san "$_san"`
	if [ $? -ne 0 ]; then
		echo $_tf
		return 1
	fi
	out=`$OS req -config $_tf -new -key $_key -passin file:$KEYDIR/$_n.pass -out $REQDIR/$_n.req -days $_days`
	if [ $? -ne 0 ]; then
		cat $_tf >&2
		rm -f $_tf
		echo $out
		return 1
	fi
	echo $REQDIR/$_n.req
	rm -f $_tf
	return 0
}

function get_config {
	local _ca=$1; shift;
	local _n
	local _k
	local _kv
	local _v=0
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			-key)
				_k=$2
				shift; shift;;
			-val*)
				_v=1
				shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	if [ -z "$_n" ]; then
		echo "no name specified"
		return 1
	fi
	if [ -z "$_k" ]; then
		echo "no key specified"
		return 1
	fi
	_kv=`cat $HOME/config/$_n | grep -i $_k`
	if [ $_v -eq 0 ]; then
		echo $_kv
	else
		echo $_kv | cut -f2 -d=
	fi
	return 0
}

function set_config {
	local _ca=$1; shift;
	local _n
	local _k
	local _kv
	local _v
	local _d=0
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			-key)
				_k=$2
				shift; shift;;
			-val*)
				_v=$2
				shift; shift;;
			-d)
				_d=1
				shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	if [ -z "$_n" ]; then
		echo "no name specified"
		return 1
	fi
	if [ -z "$_k" ]; then
		echo "no key specified"
		return 1
	fi
	if [ -z "$_v" -a $_d -eq 0 ]; then
		echo "no value specified"
		return 1
	fi
	if [ ! -z "$_v" -a $_d -eq 1 ]; then
		echo "can only specify value or delete, not both"
		return 1
	fi
	_tf=`mktemp` || die 1 "set_config: mktemp"
	if [ $_d -eq 0 ]; then
		cat $HOME/config/$_n | sed -r "s~(^$_k[[:space:]]*=[[:space:]]*).*~\1$_v~" > $_tf
	else
		cat $HOME/config/$_n | sed -r "/^$_k[[:space:]]*=/d" > $_tf
	fi
	mv -f $_tf $HOME/config/$_n
#	cat $HOME/config/$_n >&2
	return 0
}

function sign_req {
	local _ca=$1; shift;
	[ -z "$_ca" ] && return 1
	local _n
	local _file
	local _days
	local _san
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
#			-csr)
#				_file=$2
#				shift; shift;;
			-days)
				_days=$2
				shift; shift;;
			-san)
				if [ ! -z "$2" ]; then
					_san="$_san $2"
				fi
				shift; shift;;
			*)
				echo "unknown option $1"
				return 1
				;;
		esac
	done
	if [ ! -z "$_n" -a ! -z "$_file" ]; then
		echo "must specify name or csr"
		return 1
	fi
	if [ ! -z "$_n" ]; then
		_file=$REQDIR/$_n.req
	fi
	if [ ! -f $_file ]; then
		echo "cannot find request file"
		return 1
	fi
	if [ -z "$_days" ]; then
		_days=$CERTDAYS
	fi
	_tf=`build_config "$_ca" "ca" -policy policy_sign -ext extension_cert`
	if [ $? -ne 0 ]; then
		echo $_tf
		return 1
	fi
	prep_serial $_ca
#	out=`$OS ca -verbose -batch -config $_tf -out $CERTDIR/$_n.crt -in $_file -keyfile $KEYDIR/$ROOTKEY -key file:$KEYDIR/${ROOTKEY%%.key}.pass -cert $CERTDIR/$ROOTCERT -out $REQDIR/$_n.req -days $_days`
	out=`$OS ca -verbose -batch -config $_tf -out $CERTDIR/$_n.crt -in $_file -keyfile $KEYDIR/$ROOTKEY -cert $CERTDIR/$ROOTCERT -in $REQDIR/$_n.req -days $_days`
	if [ $? -ne 0 ]; then
		cat $_tf >&2
		rm -f $_tf
		echo $out
		return 1
	fi
	# rename req if it is in our reqdir
	if [ ! -z "$_n" ]; then
		mv -f $REQDIR/$_n.req $REQDIR/$_n.signed
	fi
	rm -f $_tf
	return 0
}

function show_cert {
	local _ca=$1; shift;
	local _n
	local _s=0
	local _e=0
	local _opts
	[ -z "$_ca" ] && return 1
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			-sub*hash)
				_opts="-subject_hash $_opts"
				shift;;
			-iss*hash)
				_opts="-issuer_hash $_opts"
				shift;;
			-ser*)
				_opts="-serial $_opts"
				shift;;
			-sub*)
				_opts="-subject $_opts"
				shift;;
			-iss*)
				_opts="-issuer $_opts"
				shift;;
			-fin*)
				_opts="-fingerprint $_opts"
				shift;;
			-exp*)
				_opts="-enddate $_opts"
				shift;;
			-email)
				_opts="-email $_opts"
				shift;;

			*)
				shift;;
		esac
	done
	if [ -z "$_n" ]; then
		_n="*"
	fi
	if [ -z "$_opts" ]; then
		_opts="-text"
	fi
	for i in `find $CERTDIR/ -name $_n.crt -print`; do
		_pn=${i##*/}
		# skip root cert if name not specified
		[ "$_n" == "*" -a "$_pn" == "$ROOTCERT" ] && continue;
		echo -n "${_pn%%.req}: "
		$OS x509 -in $i -noout $_opts
	done
	return 0
}

function show_requests {
	local _ca=$1; shift;
	local _n
	[ -z "$_ca" ] && return 1
	while [ $# -ne 0 ]; do
		case "$1" in
			-name)
				_n=$2
				shift; shift;;
			*)
				shift;;
		esac
	done
	if [ -z "$_n" ]; then
		_n="*"
	fi
	for i in `find $REQDIR/ -name $_n.req -print` ; do
		_pn=${i##*/}
		echo -n "${_pn%%.req}: "
		$OS req -in $i -noout -subject
	done
}

if [ $# -lt 2 ]; then
	syntax 1
fi

CA=$1; shift;

if [ "$1" == "init" ]; then
	out=`init_ca $CA`
	if [ $? -ne 0 ]; then
		die 1 $out
	fi
	die 0 "CA initialized"
fi

out=`check_ca $CA` || die 1 "$out"
read_config $CA

while [ $# -ne 0 ]; do
	case "$1" in
		create)
			shift
			[ -z "$1" ] && die 1 "nothing to do"
			case "$1" in
				root)
					shift;
					out=`create_root $CA $*` || die 1 "$out"
					# success... now eat rest of args
					while [ $# -ne 0 ]; do shift; done
					;;
				key)
					shift;
					out=`create_key $CA $*` || die 1 "$out"
					# success... now eat rest of args
					while [ $# -ne 0 ]; do shift; done
					;;
				req*)
					shift;
					out=`create_csr $CA $*` || die 1 "$out"
					# success... now eat rest of args
					while [ $# -ne 0 ]; do shift; done
					;;
				crl)
					shift
					;;
				*)
					die 1 "Unknown command $1"
					shift;;
			esac
			;;
		config)
			shift;
			[ -z "$1" ] && die 1 "nothing to do"
			case "$1" in
				list)
					[ -z "$2" ] && die 1 "nothing to do"
					case "$2" in
						mac*)
							cat $HOME/config/macros
							;;
						pol*)
							for i in `ls $HOME/config/policy_*`; do
								echo "___ ${i##*/} ___"
								cat $i
							done
							;;
						ext*)
							for i in `ls $HOME/config/extension_*`; do
								echo "___ ${i##*/} ___"
								cat $i
							done
							;;
						*)
							die 1 "Unknown command $2"
							;;
					esac
					while [ $# -ne 0 ]; do shift; done
					;;
				get)
					shift
					[ -z "$1" ] && die 1 "nothing to do"
					case "$1" in
						mac*)
							shift
							out=`get_config $CA -name macros $*` || die 1 "$out"
							# success... now eat rest of args
							echo $out
							while [ $# -ne 0 ]; do shift; done
							;;
						pol*|ext*)
							shift
							out=`get_config $CA $*` || die 1 "$out"
							# success... now eat rest of args
							echo $out
							while [ $# -ne 0 ]; do shift; done
							;;
						*)
							die 1 "Unknown command $1"
							;;
					esac
					while [ $# -ne 0 ]; do shift; done
					;;
				set)
					shift
					[ -z "$1" ] && die 1 "nothing to do"
					case "$1" in
						mac*)
							shift
							out=`set_config $CA -name macros $*` || die 1 "$out"
							# success... now eat rest of args
							echo $out
							while [ $# -ne 0 ]; do shift; done
							;;
						pol*|ext*)
							shift
							out=`set_config $CA $*` || die 1 "$out"
							# success... now eat rest of args
							echo $out
							while [ $# -ne 0 ]; do shift; done
							;;
						*)
							die 1 "Unknown command $1"
							;;
					esac
					while [ $# -ne 0 ]; do shift; done
					;;

				*)
					die 1 "Unknown command $1"
					shift;;
			esac
			while [ $# -ne 0 ]; do shift; done
			;;
		sign)
			shift;
			[ -z "$1" ] && die 1 "noting to do"
			out=`sign_req $CA $*` || die 1 "$out"
			echo $out
			while [ $# -ne 0 ]; do shift; done
			;;
		show)
			shift;
			[ -z "$1" ] && die 1 "nothing to do"
			case "$1" in
				root)
					shift;
					show_cert $CA -name ${ROOTCERT%%.crt} $*
					while [ $# -ne 0 ]; do shift; done
					;;
				req*)
					shift;
					show_requests $CA $*
					while [ $# -ne 0 ]; do shift; done
					;;
				crt|cert*)
					shift;
					show_cert $CA $*
					while [ $# -ne 0 ]; do shift; done
					;;
				*)
					die 1 "Unknown command $1"
					shift;;
			esac
			while [ $# -ne 0 ]; do shift; done
			;;
		*)
			die 1 "Unknown command $1"
			break;;
	esac
done


